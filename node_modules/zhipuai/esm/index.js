import KeepAliveAgent from 'agentkeepalive';
import fetch$1 from 'node-fetch';
import { inspect } from 'util';
import jwt from 'jsonwebtoken';

const defaultHttpAgent = new KeepAliveAgent({
    keepAlive: true,
    timeout: 5 * 60 * 1000,
});
const defaultHttpsAgent = new KeepAliveAgent.HttpsAgent({
    keepAlive: true,
    timeout: 5 * 60 * 1000,
});
function getRuntime() {
    return {
        kind: 'node',
        fetch: fetch$1,
        getDefaultAgent: (url) => url.startsWith('https') ? defaultHttpsAgent : defaultHttpAgent,
    };
}

let kind = undefined;
let fetch = undefined;
let getDefaultAgent = undefined;
function setShims(shims) {
    kind = shims.kind;
    fetch = shims.fetch;
    getDefaultAgent = shims.getDefaultAgent;
}

if (!kind) {
    setShims(getRuntime());
}

class ZhipuAIError extends Error {
}

const isRunningInBrowser = () => {
    return (typeof window !== 'undefined' &&
        typeof window.document !== 'undefined' &&
        typeof navigator !== 'undefined');
};

function log(msg) {
    process.stderr.write(`[zhipuai::diagnostics] ${msg}` + '\n');
}
function printDiagnostics(...args) {
    if (process.env.ZHIPUAI_VERBOSE !== '1') {
        return;
    }
    log(inspect(args, false, 10, true));
}

const readEnv = (env) => {
    if (typeof process !== 'undefined') {
        return process.env?.[env]?.trim() ?? undefined;
    }
    return undefined;
};

const safeJSON = (text) => {
    try {
        return JSON.parse(text);
    }
    catch (err) {
        return undefined;
    }
};

function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
    for (const k in newHeaders) {
        if (!hasOwn(newHeaders, k))
            continue;
        const lowerKey = k.toLowerCase();
        if (!lowerKey)
            continue;
        const val = newHeaders[k];
        if (val === null) {
            delete targetHeaders[lowerKey];
        }
        else if (val !== undefined) {
            targetHeaders[lowerKey] = val;
        }
    }
}

const castToError = (err) => {
    if (err instanceof Error)
        return err;
    return new Error(err);
};

const createResponseHeaders = (headers) => {
    return new Proxy(Object.fromEntries(headers.entries()), {
        get(target, name) {
            const key = name.toString();
            return target[key.toLowerCase()] || target[key];
        },
    });
};

const VERSION = '2.0.0';

let _platformHeaders;
const getPlatformHeaders = () => {
    return (_platformHeaders ??= getPlatformProperties());
};
const getPlatformProperties = () => {
    if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {
        return {
            'X-Stainless-Lang': 'js',
            'X-Stainless-Package-Version': VERSION,
            'X-Stainless-OS': normalizePlatform(process.platform),
            'X-Stainless-Arch': normalizeArch(process.arch),
            'X-Stainless-Runtime': 'node',
            'X-Stainless-Runtime-Version': process.version,
        };
    }
    return {
        'X-Stainless-Lang': 'js',
        'X-Stainless-Package-Version': VERSION,
        'X-Stainless-OS': 'Unknown',
        'X-Stainless-Arch': 'unknown',
        'X-Stainless-Runtime': 'unknown',
        'X-Stainless-Runtime-Version': 'unknown',
    };
};
const normalizeArch = (arch) => {
    if (arch === 'x32')
        return 'x32';
    if (arch === 'x86_64' || arch === 'x64')
        return 'x64';
    if (arch === 'arm')
        return 'arm';
    if (arch === 'aarch64' || arch === 'arm64')
        return 'arm64';
    if (arch)
        return `other:${arch}`;
    return 'unknown';
};
const normalizePlatform = (platform) => {
    platform = platform.toLowerCase();
    if (platform.includes('ios'))
        return 'iOS';
    if (platform === 'android')
        return 'Android';
    if (platform === 'darwin')
        return 'MacOS';
    if (platform === 'win32')
        return 'Windows';
    if (platform === 'freebsd')
        return 'FreeBSD';
    if (platform === 'openbsd')
        return 'OpenBSD';
    if (platform === 'linux')
        return 'Linux';
    if (platform)
        return `Other:${platform}`;
    return 'Unknown';
};

const startsWithSchemeRegexp = new RegExp('^(?:[a-z]+:)?//', 'i');
const isAbsoluteURL = (url) => {
    return startsWithSchemeRegexp.test(url);
};

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const uuid4 = () => {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16) | 0;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
};

const validatePositiveInteger = (name, n) => {
    if (typeof n !== 'number' || !Number.isInteger(n)) {
        throw new ZhipuAIError(`${name} must be an integer`);
    }
    if (n < 0) {
        throw new ZhipuAIError(`${name} must be a positive integer`);
    }
    return n;
};

class APIError extends ZhipuAIError {
    status;
    headers;
    error;
    code;
    param;
    type;
    request_id;
    constructor(status, error, message, headers) {
        super(`${APIError.makeMessage(status, error, message)}`);
        this.status = status;
        this.headers = headers;
        this.request_id = headers?.['x-request-id'];
        const data = error;
        this.error = data;
        this.code = data?.['code'];
        this.param = data?.['param'];
        this.type = data?.['type'];
    }
    static makeMessage(status, error, message) {
        const msg = error?.message
            ? typeof error.message === 'string'
                ? error.message
                : JSON.stringify(error.message)
            : error
                ? JSON.stringify(error)
                : message;
        if (status && msg) {
            return `${status} ${msg}`;
        }
        if (status) {
            return `${status} status code (no body)`;
        }
        if (msg) {
            return msg;
        }
        return '(no status code or body)';
    }
    static generate(status, errorResponse, message, headers) {
        if (!status) {
            return new APIConnectionError({ cause: castToError(errorResponse) });
        }
        const error = errorResponse?.['error'];
        if (status === 400) {
            return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
            return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
            return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
            return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
            return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
            return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
            return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
            return new InternalServerError(status, error, message, headers);
        }
        return new APIError(status, error, message, headers);
    }
}
class APIUserAbortError extends APIError {
    status = undefined;
    constructor({ message } = {}) {
        super(undefined, undefined, message || 'Request was aborted.', undefined);
    }
}
class APIConnectionError extends APIError {
    status = undefined;
    constructor({ message, cause, }) {
        super(undefined, undefined, message || 'Connection error.', undefined);
        if (cause)
            this.cause = cause;
    }
}
class APIConnectionTimeoutError extends APIConnectionError {
    constructor({ message } = {}) {
        super({ message: message ?? 'Request timed out.' });
    }
}
class BadRequestError extends APIError {
    status = 400;
}
class AuthenticationError extends APIError {
    status = 401;
}
class PermissionDeniedError extends APIError {
    status = 403;
}
class NotFoundError extends APIError {
    status = 404;
}
class ConflictError extends APIError {
    status = 409;
}
class UnprocessableEntityError extends APIError {
    status = 422;
}
class RateLimitError extends APIError {
    status = 429;
}
class InternalServerError extends APIError {
}

function findDoubleNewlineIndex(buffer) {
    const lf = 0x0a;
    const cr = 0x0d;
    for (let i = 0; i < buffer.length - 2; i++) {
        if (buffer[i] === lf && buffer[i + 1] === lf) {
            return i + 2;
        }
        if (buffer[i] === cr && buffer[i + 1] === cr) {
            return i + 2;
        }
        if (buffer[i] === cr &&
            buffer[i + 1] === lf &&
            i + 3 < buffer.length &&
            buffer[i + 2] === cr &&
            buffer[i + 3] === lf) {
            return i + 4;
        }
    }
    return -1;
}
async function* iterSSEChunks(iterator) {
    let data = new Uint8Array();
    for await (const chunk of iterator) {
        if (chunk == null) {
            continue;
        }
        const binaryChunk = chunk instanceof ArrayBuffer
            ? new Uint8Array(chunk)
            : typeof chunk === 'string'
                ? new TextEncoder().encode(chunk)
                : chunk;
        const newData = new Uint8Array(data.length + binaryChunk.length);
        newData.set(data);
        newData.set(binaryChunk, data.length);
        data = newData;
        let patternIndex;
        while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
            yield data.slice(0, patternIndex);
            data = data.slice(patternIndex);
        }
    }
    if (data.length > 0) {
        yield data;
    }
}

class LineDecoder {
    static NEWLINE_CHARS = new Set(['\n', '\r']);
    static NEWLINE_REGEXP = /\r\n|[\n\r]/g;
    buffer;
    trailingCR;
    textDecoder;
    constructor() {
        this.buffer = [];
        this.trailingCR = false;
    }
    decode(chunk) {
        let text = this.decodeText(chunk);
        if (this.trailingCR) {
            text = '\r' + text;
            this.trailingCR = false;
        }
        if (text.endsWith('\r')) {
            this.trailingCR = true;
            text = text.slice(0, -1);
        }
        if (!text) {
            return [];
        }
        const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');
        let lines = text.split(LineDecoder.NEWLINE_REGEXP);
        if (trailingNewline) {
            lines.pop();
        }
        if (lines.length === 1 && !trailingNewline) {
            this.buffer.push(lines[0]);
            return [];
        }
        if (this.buffer.length > 0) {
            lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];
            this.buffer = [];
        }
        if (!trailingNewline) {
            this.buffer = [lines.pop() || ''];
        }
        return lines;
    }
    decodeText(bytes) {
        if (bytes == null) {
            return '';
        }
        if (typeof bytes === 'string') {
            return bytes;
        }
        if (typeof Buffer !== 'undefined') {
            if (bytes instanceof Buffer) {
                return bytes.toString();
            }
            if (bytes instanceof Uint8Array) {
                return Buffer.from(bytes).toString();
            }
            throw new ZhipuAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
        }
        if (typeof TextDecoder !== 'undefined') {
            if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
                this.textDecoder ??= new TextDecoder('utf8');
                return this.textDecoder.decode(bytes);
            }
            throw new ZhipuAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
        }
        throw new ZhipuAIError('Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.');
    }
    flush() {
        if (!this.buffer.length && !this.trailingCR) {
            return [];
        }
        const lines = [this.buffer.join('')];
        this.buffer = [];
        this.trailingCR = false;
        return lines;
    }
}

function readableStreamAsyncIterable(stream) {
    if (stream[Symbol.asyncIterator])
        return stream;
    const reader = stream.getReader();
    return {
        async next() {
            try {
                const result = await reader.read();
                if (result?.done)
                    reader.releaseLock();
                return result;
            }
            catch (e) {
                reader.releaseLock();
                throw e;
            }
        },
        async return() {
            const cancelPromise = reader.cancel();
            reader.releaseLock();
            await cancelPromise;
            return { done: true, value: undefined };
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}

function partition(str, delimiter) {
    const index = str.indexOf(delimiter);
    if (index !== -1) {
        return [
            str.substring(0, index),
            delimiter,
            str.substring(index + delimiter.length),
        ];
    }
    return [str, '', ''];
}
class SSEDecoder {
    data;
    event;
    chunks;
    constructor() {
        this.event = null;
        this.data = [];
        this.chunks = [];
    }
    decode(line) {
        if (line.endsWith('\r')) {
            line = line.substring(0, line.length - 1);
        }
        if (!line) {
            if (!this.event && !this.data.length) {
                return null;
            }
            const sse = {
                event: this.event,
                data: this.data.join('\n'),
                raw: this.chunks,
            };
            this.event = null;
            this.data = [];
            this.chunks = [];
            return sse;
        }
        this.chunks.push(line);
        if (line.startsWith(':')) {
            return null;
        }
        const partitionResult = partition(line, ':');
        const fieldName = partitionResult[0];
        let value = partitionResult[2];
        if (value.startsWith(' ')) {
            value = value.substring(1);
        }
        if (fieldName === 'event') {
            this.event = value;
        }
        else if (fieldName === 'data') {
            this.data.push(value);
        }
        return null;
    }
}

async function* iterSSEMessages(response, controller) {
    if (!response.body) {
        controller.abort();
        throw new ZhipuAIError(`Attempted to iterate over a response with no body`);
    }
    const sseDecoder = new SSEDecoder();
    const lineDecoder = new LineDecoder();
    const iter = readableStreamAsyncIterable(response.body);
    for await (const sseChunk of iterSSEChunks(iter)) {
        const lines = lineDecoder.decode(sseChunk);
        for (const line of lines) {
            const sse = sseDecoder.decode(line);
            if (sse) {
                yield sse;
            }
        }
    }
    for (const line of lineDecoder.flush()) {
        const sse = sseDecoder.decode(line);
        if (sse) {
            yield sse;
        }
    }
}

class Stream {
    iterator;
    controller;
    constructor(iterator, controller) {
        this.iterator = iterator;
        this.controller = controller;
    }
    static fromSSEResponse(response, controller) {
        let consumed = false;
        async function* iterator() {
            if (consumed) {
                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');
            }
            consumed = true;
            let done = false;
            try {
                for await (const sse of iterSSEMessages(response, controller)) {
                    if (done) {
                        continue;
                    }
                    if (sse.data.startsWith('[DONE]')) {
                        done = true;
                        continue;
                    }
                    let data;
                    try {
                        data = JSON.parse(sse.data);
                    }
                    catch (err) {
                        console.error(`Could not parse message into JSON:`, sse.data);
                        console.error(`From chunk:`, sse.raw);
                        throw err;
                    }
                    if (sse.event === null) {
                        if (data && data.error) {
                            throw new APIError(undefined, data.error, undefined, undefined);
                        }
                        yield data;
                    }
                    else {
                        if (sse.event === 'error') {
                            throw new APIError(undefined, data.error, data.message, undefined);
                        }
                        yield { event: sse.event, data };
                    }
                }
                done = true;
            }
            catch (e) {
                if (e instanceof Error && e.name === 'AbortError') {
                    return;
                }
                throw e;
            }
            finally {
                if (!done) {
                    controller.abort();
                }
            }
        }
        return new Stream(iterator, controller);
    }
    [Symbol.asyncIterator]() {
        return this.iterator();
    }
}

async function defaultParseResponse(props) {
    const { response } = props;
    if (props.options.stream) {
        printDiagnostics('defaultParseResponse::stream', response.status, response.url, response.headers, response.body);
        if (props.options.__streamClass) {
            return props.options.__streamClass.fromSSEResponse(response, props.controller);
        }
        return Stream.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
        return null;
    }
    const contentType = response.headers.get('content-type');
    const isJson = contentType?.includes('application/json') ||
        contentType?.includes('application/vnd.api+json');
    if (isJson) {
        const json = await response.json();
        printDiagnostics('defaultParseResponse::json', response.status, response.url, response.headers, json);
        return json;
    }
    const text = await response.text();
    printDiagnostics('defaultParseResponse::text', response.status, response.url, response.headers, text);
    return text;
}
class APIPromise extends Promise {
    responsePromise;
    parseResponse;
    parsedPromise;
    constructor(responsePromise, parseResponse = defaultParseResponse) {
        super((resolve) => {
            resolve(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse;
    }
    asResponse() {
        return this.responsePromise.then((p) => p.response);
    }
    async withResponse() {
        const [data, response] = await Promise.all([
            this.parse(),
            this.asResponse(),
        ]);
        return { data, response };
    }
    parse() {
        if (!this.parsedPromise) {
            this.parsedPromise = this.responsePromise.then(this.parseResponse);
        }
        return this.parsedPromise;
    }
    then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return this.parse().catch(onrejected);
    }
    finally(onfinally) {
        return this.parse().finally(onfinally);
    }
}

class APIClient {
    baseURL;
    maxRetries;
    timeout;
    httpAgent;
    fetch;
    idempotencyHeader;
    constructor({ baseURL, maxRetries = 2, timeout = 10 * 60 * 1000, httpAgent, fetch: overridenFetch, }) {
        this.baseURL = baseURL;
        this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);
        this.timeout = validatePositiveInteger('timeout', timeout);
        this.httpAgent = httpAgent;
        this.fetch = overridenFetch ?? fetch;
    }
    async prepareOptions(options) { }
    async prepareRequest(request, { url, options }) { }
    getRequestClient() {
        return { fetch: this.fetch };
    }
    authHeaders(options) {
        return {};
    }
    defaultQuery() {
        return undefined;
    }
    defaultHeaders(options) {
        return {
            Accept: 'application/json',
            'Content-Type': 'application/json',
            'User-Agent': this.getUserAgent(),
            ...getPlatformHeaders(),
            ...this.authHeaders(options),
        };
    }
    defaultIdempotencyKey() {
        return `stainless-node-retry-${uuid4()}`;
    }
    validateHeaders(headers, customHeaders) { }
    getUserAgent() {
        return `${this.constructor.name}/JS ${VERSION}`;
    }
    calculateContentLength(body) {
        if (typeof body === 'string') {
            if (typeof Buffer !== 'undefined') {
                return Buffer.byteLength(body, 'utf8').toString();
            }
            if (typeof TextEncoder !== 'undefined') {
                const encoder = new TextEncoder();
                const encoded = encoder.encode(body);
                return encoded.length.toString();
            }
        }
        return null;
    }
    stringifyQuery(query) {
        return Object.entries(query)
            .filter(([_, value]) => typeof value !== 'undefined')
            .map(([key, value]) => {
            if (typeof value === 'string' ||
                typeof value === 'number' ||
                typeof value === 'boolean') {
                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
            }
            if (value == null) {
                return `${encodeURIComponent(key)}=`;
            }
            throw new ZhipuAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
        })
            .join('&');
    }
    buildURL(path, query) {
        const url = isAbsoluteURL(path)
            ? new URL(path)
            : new URL(this.baseURL +
                (this.baseURL.endsWith('/') && path.startsWith('/')
                    ? path.slice(1)
                    : path));
        const defaultQuery = this.defaultQuery();
        query = {
            ...defaultQuery,
            ...query,
        };
        url.search = this.stringifyQuery(query);
        return url.toString();
    }
    buildHeaders({ options, headers, contentLength, }) {
        const reqHeaders = {};
        if (contentLength) {
            reqHeaders['content-length'] = contentLength;
        }
        const defaultHeaders = this.defaultHeaders(options);
        applyHeadersMut(reqHeaders, defaultHeaders);
        applyHeadersMut(reqHeaders, headers);
        this.validateHeaders(reqHeaders, headers);
        return reqHeaders;
    }
    buildRequest(options) {
        const method = options.method;
        const body = JSON.stringify(options.body, null, 2);
        const contentLength = this.calculateContentLength(body);
        const url = this.buildURL(options.path, options.query);
        if ('timeout' in options) {
            validatePositiveInteger('timeout', options.timeout);
        }
        const timeout = options.timeout ?? this.timeout;
        const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent?.(url);
        const minAgentTimeout = timeout + 1000;
        if (typeof httpAgent?.options?.timeout === 'number' &&
            minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
            httpAgent.options.timeout = minAgentTimeout;
        }
        const headers = options.headers || {};
        if (this.idempotencyHeader && method !== 'get') {
            if (!options.idempotencyKey) {
                options.idempotencyKey = this.defaultIdempotencyKey();
            }
            headers[this.idempotencyHeader] = options.idempotencyKey;
        }
        const reqHeaders = this.buildHeaders({
            options,
            headers,
            contentLength,
        });
        const req = {
            method,
            ...(body ? { body } : {}),
            headers: reqHeaders,
            ...(httpAgent ? { agent: httpAgent } : {}),
            signal: options.signal ?? null,
        };
        return {
            url,
            req,
            timeout,
        };
    }
    async fetchWithTimeout(url, reqInit, timeoutNumber, controller) {
        const { signal, ...options } = reqInit || {};
        if (signal) {
            signal.addEventListener('abort', () => controller.abort());
        }
        const timeout = setTimeout(() => controller.abort(), timeoutNumber);
        return this.getRequestClient()
            .fetch.call(undefined, url, {
            signal: controller.signal,
            method: 'get',
            ...options,
        })
            .finally(() => {
            clearTimeout(timeout);
        });
    }
    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8.0;
        const numRetries = maxRetries - retriesRemaining;
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1000;
    }
    async retryRequest(options, retriesRemaining, responseHeaders) {
        let timeoutMillis;
        const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];
        if (retryAfterMillisHeader) {
            const timeoutMs = parseFloat(retryAfterMillisHeader);
            if (!Number.isNaN(timeoutMs)) {
                timeoutMillis = timeoutMs;
            }
        }
        const retryAfterHeader = responseHeaders?.['retry-after'];
        if (retryAfterHeader && !timeoutMillis) {
            const timeoutSeconds = parseFloat(retryAfterHeader);
            if (!Number.isNaN(timeoutSeconds)) {
                timeoutMillis = timeoutSeconds * 1000;
            }
            else {
                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
            }
        }
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {
            const maxRetries = options.maxRetries ?? this.maxRetries;
            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await sleep(timeoutMillis);
        return this.makeRequest(options, retriesRemaining - 1);
    }
    shouldRetry(response) {
        const shouldRetryHeader = response.headers.get('x-should-retry');
        if (shouldRetryHeader === 'true')
            return true;
        if (shouldRetryHeader === 'false')
            return false;
        if (response.status === 408)
            return true;
        if (response.status === 409)
            return true;
        if (response.status === 429)
            return true;
        if (response.status >= 500)
            return true;
        return false;
    }
    makeStatusError(status, error, message, headers) {
        return APIError.generate(status, error, message, headers);
    }
    async makeRequest(optionsInput, retriesRemaining) {
        const options = await optionsInput;
        if (retriesRemaining == null) {
            retriesRemaining = options.maxRetries ?? this.maxRetries;
        }
        await this.prepareOptions(options);
        const { req, timeout, url } = this.buildRequest(options);
        await this.prepareRequest(req, { url, options });
        printDiagnostics('apiClient::makeRequest', {
            req,
            url,
            options,
        });
        if (options.signal?.aborted) {
            throw new APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
        if (response instanceof Error) {
            if (options.signal?.aborted) {
                throw new APIUserAbortError();
            }
            if (retriesRemaining > 0) {
                return this.retryRequest(options, retriesRemaining);
            }
            if (response.name === 'AbortError') {
                throw new APIConnectionTimeoutError();
            }
            throw new APIConnectionError({ cause: response });
        }
        const responseHeaders = createResponseHeaders(response.headers);
        if (!response.ok) {
            if (retriesRemaining && this.shouldRetry(response)) {
                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
                printDiagnostics(`response (error; ${retryMessage})`, response.status, url, responseHeaders);
                return this.retryRequest(options, retriesRemaining, responseHeaders);
            }
            const errText = await response
                .text()
                .catch((err) => castToError(err).message);
            const errJSON = safeJSON(errText);
            const errMessage = errJSON ? undefined : errText;
            const retryMessage = retriesRemaining
                ? `(error; no more retries left)`
                : `(error; not retryable)`;
            printDiagnostics(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
            const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
            throw err;
        }
        return {
            response,
            options,
            controller,
        };
    }
    request(options, remainingRetries = null) {
        return new APIPromise(this.makeRequest(options, remainingRetries));
    }
    methodRequest(method, path, options) {
        return this.request({
            method,
            path,
            ...options,
        });
    }
    get(path, options) {
        return this.methodRequest('get', path, options);
    }
    post(path, options) {
        return this.methodRequest('post', path, options);
    }
    patch(path, options) {
        return this.methodRequest('patch', path, options);
    }
    put(path, options) {
        return this.methodRequest('put', path, options);
    }
    delete(path, options) {
        return this.methodRequest('delete', path, options);
    }
}

function generateToken(apiKey, timestamp, ttl) {
    const [id, secret] = apiKey.split('.');
    const exp = timestamp + ttl;
    const token = jwt.sign({
        api_key: id,
        exp,
        timestamp: timestamp,
    }, secret, {
        header: {
            alg: 'HS256',
            sign_type: 'SIGN',
        },
    });
    return token;
}

class ZhipuAIAuthManger {
    cachedToken;
    options = {
        tokenTTL: 3 * 60 * 1000,
        tokenRefreshTTL: 30 * 1000,
    };
    getToken(apiKey) {
        if (this.cachedToken &&
            this.cachedToken.exp - this.options.tokenRefreshTTL > Date.now()) {
            return this.cachedToken.token;
        }
        this.cachedToken = undefined;
        const now = Date.now();
        const token = generateToken(apiKey, now, this.options.tokenTTL);
        this.cachedToken = {
            token,
            exp: now + this.options.tokenTTL,
        };
        return token;
    }
}

class APIResource {
    _client;
    constructor(client) {
        this._client = client;
    }
}

class ChatCompletionTasks extends APIResource {
    create(body, options) {
        return this._client.post('/async/chat/completions', {
            body,
            ...options,
        });
    }
    retrieve(body, options) {
        return this._client.get(`/async-result/${body.id}`, {
            ...options,
        });
    }
}

class ChatCompletions extends APIResource {
    tasks = new ChatCompletionTasks(this._client);
    create(body, options) {
        return this._client.post('/chat/completions', {
            body,
            ...options,
            stream: body.stream ?? false,
        });
    }
}

class Chat extends APIResource {
    completions = new ChatCompletions(this._client);
}

class Embeddings extends APIResource {
    create(body, options) {
        return this._client.post('/embeddings', {
            body,
            ...options,
        });
    }
}

class Images extends APIResource {
    generate(body, options) {
        return this._client.post('/images/generations', {
            body,
            ...options,
        });
    }
}

class ZhipuAI extends APIClient {
    apiKey;
    organization;
    project;
    options;
    authManager = new ZhipuAIAuthManger();
    constructor({ baseURL = readEnv('ZHIPUAI_BASE_URL'), apiKey = readEnv('ZHIPUAI_API_KEY'), organization = readEnv('ZHIPUAI_ORG_ID') ?? null, project = readEnv('ZHIPUAI_PROJECT_ID') ?? null, ...opts } = {}) {
        if (apiKey === undefined) {
            throw new ZhipuAIError('The ZHIPUAI_API_KEY environment variable is missing or empty; ' +
                'either provide it, or instantiate the ZhipuAI client with an apiKey option, ' +
                "like new ZhipuAI({ apiKey: 'My API Key' }).");
        }
        const options = {
            apiKey,
            organization,
            project,
            ...opts,
            baseURL: baseURL || `https://open.bigmodel.cn/api/paas/v4`,
        };
        if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
            throw new ZhipuAIError("It looks like you're running in a browser-like environment.\n\n" +
                'This is disabled by default, as it risks exposing your secret API credentials to attackers.\n' +
                'If you understand the risks and have appropriate mitigations in place,\n' +
                'you can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\n' +
                'new ZhipuAI({ apiKey, dangerouslyAllowBrowser: true });\n');
        }
        super({
            baseURL: options.baseURL,
            timeout: options.timeout ?? 10 * 60 * 1000,
            httpAgent: options.httpAgent,
            maxRetries: options.maxRetries,
            fetch: options.fetch,
        });
        this.options = options;
        this.apiKey = apiKey;
        this.organization = organization;
        this.project = project;
    }
    chat = new Chat(this);
    embeddings = new Embeddings(this);
    images = new Images(this);
    defaultQuery() {
        return this.options.defaultQuery;
    }
    authHeaders(options) {
        return {
            Authorization: `Bearer ${this.authManager.getToken(this.apiKey)}`,
        };
    }
}

export { Chat, ChatCompletions, ZhipuAI };
